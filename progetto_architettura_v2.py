# -*- coding: utf-8 -*-
"""progetto-architettura-v2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E-Cy8UxvPTUDxlKjOcH4gaC6Edt3w5-Y

#progetto di architettura dati:

* prendere un "database" assunto pulito,
* sporcarlo in maniera controllata ed incrementale (tranne il testset)
* ed goni stadio di sporcature utilizzare 3 algoritmi di ML
* analizzare i risultati facendo il confronto

valutare il downsampling

usare sickit-learn dato che h2o fa casino con i vari calcoli di roc ed auc

ricordarsi per le categoriche non-ordinali il one-hot-encoding e poi l'eleiminazione di una colonna per rendere i valori non-co-dipendenti

per le altre categoriche si può fare il label encoding se ritenuto opportuno

vedere se rimuovere gli auto-previsione corretta (se hai degli insoluti a priori è un no)

per sporcare il dataset:

*   ripetizione di voci del datset
*   errori di selezione (es: sostituire tot voci maschio con femmina ma non con valori random)

*   rendere alcuni dati inconsistenti
*   vedere se NaN crea o meno errori durante l'esecuzione, risposta: si, da problemi con albero e gauss, risolto attraverso imputazione con la media
"""

from pathlib import Path

import pandas as pd
import numpy as np
import random
import string
import os
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import OneHotEncoder
from sklearn.preprocessing import StandardScaler
from sklearn.neural_network import MLPClassifier
from sklearn.inspection import permutation_importance
from sklearn.impute import SimpleImputer


from sklearn.tree import DecisionTreeClassifier, plot_tree

from sklearn.metrics import accuracy_score, f1_score, roc_curve, auc, confusion_matrix,roc_auc_score
import matplotlib.pyplot as plt
import seaborn as sns


from sklearn.ensemble import RandomForestClassifier # Import Random Forest Classifier

from sklearn.naive_bayes import GaussianNB

import matplotlib.pyplot as plt

from google.colab import drive

drive.mount('/content/drive/')

if ((Path.cwd() / 'drive/MyDrive/architettura-Dati/' / 'progetto-architettura-v2.ipynb').exists()): #####

  data = pd.read_csv('drive/MyDrive/architettura-Dati/dati/loan_data.csv')

else:
  data= pd.read_csv('https://raw.githubusercontent.com/Barbera9/temp/refs/heads/main/loan_data.csv')

data.head()

categorical_cols = ['person_gender', 'person_education', 'person_home_ownership', 'loan_intent','previous_loan_defaults_on_file'] #categoriche

for col in categorical_cols:
    if col in data.columns:
        print(f"{col}: {data[col].unique()}")
    else:
        print(f"Column '{col}' not found in the DataFrame.")

"""![immagine.png](data:image/png;base64,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)

![immagine.png](data:image/png;base64,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)
"""

# Visualize the distribution of 'person_income' using a histogram or bar plot
plt.figure(figsize=(10, 6))
sns.histplot(data['person_income'], bins=300, kde=True)
plt.xlabel('Person Income (Normalized)')
plt.ylabel('Frequency')
plt.title('Distribution of Person Income')
plt.xlim(0, 1000000)
plt.show()

# Visualize the distribution of 'person_income' using a histogram or bar plot
plt.figure(figsize=(10, 6))
sns.histplot(data['person_age'], bins=125, kde=True)
plt.xlabel('Person Age (Normalized)')
plt.ylabel('Frequency')
plt.title('Distribution of Person Age')
plt.xlim(0, 100)
plt.show()

# Visualize the distribution of 'person_income' using a histogram or bar plot
plt.figure(figsize=(10, 6))
sns.histplot(data['person_emp_exp'], bins=150, kde=True)
plt.xlabel('person_emp_exp (Normalized)')
plt.ylabel('Frequency')
plt.title('Distribution of person_emp_exp')
plt.xlim(0, 100)
plt.show()

# Calculate histogram bins and counts for person_emp_exp
counts, bin_edges = np.histogram(data['person_emp_exp'], bins=150) # Use the same number of bins as in the plot

# The first bar corresponds to the first bin
first_bin_start = bin_edges[0]
first_bin_end = bin_edges[1]

print(f"The first bar represents values in the range: [{first_bin_start}, {first_bin_end})")

# Filter the DataFrame to get values within the first bin's range
values_in_first_bin = data[(data['person_emp_exp'] >= first_bin_start) & (data['person_emp_exp'] < first_bin_end)]['person_emp_exp']

print("\nValues of 'person_emp_exp' in the first bar:")
display(values_in_first_bin.head()) # Displaying the head as there might be many values
print(f"\nNumber of values in the first bar: {len(values_in_first_bin)}")

def remove_first_bin_values(data, feature_to_remove_from, percentage_to_remove):

    newData = data.copy()

    if feature_to_remove_from in newData.columns:
        feature_data = newData[feature_to_remove_from]

        # Calculate histogram bins and counts for the specified feature
        # Use a large number of bins to approximate the first bar as values >= min and < first_bin_end
        counts, bin_edges = np.histogram(feature_data.dropna(), bins=150) # Calculate bins on non-NaN data

        if len(bin_edges) > 1:
            first_bin_start = bin_edges[0]
            first_bin_end = bin_edges[1]

            # Identify rows in the first bin
            first_bin_indices = newData[(feature_data >= first_bin_start) & (feature_data < first_bin_end)].index.tolist()

            num_to_remove = int(len(first_bin_indices) * percentage_to_remove)
            num_to_remove = min(num_to_remove, len(first_bin_indices)) # Ensure not removing more than available

            if num_to_remove > 0:
                indices_to_remove = random.sample(first_bin_indices, num_to_remove)
                # Remove the entire rows based on the selected indices
                newData = newData.drop(indices_to_remove)
                print(f"Rimosso {num_to_remove} ({percentage_to_remove:.2%}) righe dalla prima barra di '{feature_to_remove_from}'.")
            else:
                print(f"Nessuna riga rimossa dalla prima barra di '{feature_to_remove_from}'.")
        else:
            print(f"Non è stato possibile determinare i bin per la feature '{feature_to_remove_from}'. Nessuna riga rimossa.")
    else:
        print(f"La feature '{feature_to_remove_from}' non è presente nel DataFrame.")

    return newData

data = remove_first_bin_values(data, feature_to_remove_from='person_emp_exp', percentage_to_remove=0.55)

# Visualize the distribution of 'person_income' using a histogram or bar plot
plt.figure(figsize=(10, 6))
sns.histplot(data['person_emp_exp'], bins=150, kde=True)
plt.xlabel('person_emp_exp (Normalized)')
plt.ylabel('Frequency')
plt.title('Distribution of person_emp_exp')
plt.xlim(0, 100)
plt.show()

"""essendo circa 10k entrate su un dataset di 45k entrate l'eliminazione dei dati potrebbe compromettere la bontà del dataset

si può notare che le vari features non hanno distribuzione perfettamente normale. Dato che , però, i valori che causano l'anomalia sulla distribuzione sono relativamente circoscritti non è necessaria un ulteriore normalizzazione (ulteriori info sotto)

loan_percent_income è definito con "Loan amount as a percentage of annual income" quindi droppo loan_percent_income per evitare multicollinarità
"""

if 'previous_loan_defaults_on_file' in data.columns:
    initial_rows = len(data)
    data = data[data['previous_loan_defaults_on_file'] != 'Yes'].copy() # Keep rows where the value is not 'Yes'
    rows_removed = initial_rows - len(data)
    print(f"Rimosse {rows_removed} righe dove 'previous_loan_defaults_on_file' era 'Yes'.")
    display(data.head())
else:
    print("La colonna 'previous_loan_defaults_on_file' non è presente nel DataFrame.")

data = data.drop('loan_percent_income', axis = 1)

data = data.drop('previous_loan_defaults_on_file', axis = 1)
display(data.head())

def downsampling(oldata):

    data = oldata.copy()

    # Conta le occorrenze delle classi di loan_status
    class_counts = data['loan_status'].value_counts()

    # Identifica la classe minoritaria e maggioritaria
    minority_class = class_counts.idxmin()
    majority_class = class_counts.idxmax()
    minority_count = class_counts[minority_class]
    majority_count = class_counts[majority_class]

    # DataFrame per la classe minoritaria
    minority_df = data[data['loan_status'] == minority_class]

    # DataFrame per la classe maggioritaria
    majority_df = data[data['loan_status'] == majority_class]

    # Downsampling della classe maggioritaria per avere lo stesso numero di campioni della classe minoritaria
    # Manteniamo random_state qui per la riproducibilità della selezione del sottoinsieme
    majority_downsampled = majority_df.sample(n=minority_count, random_state=420)

    # Concatena i DataFrame bilanciati
    balanced_df = pd.concat([minority_df, majority_downsampled])

    # Resetta l'indice del DataFrame bilanciato e mescola le righe per la riproducibilità
    data = balanced_df.sample(frac=1, random_state=420).reset_index(drop=True).copy()

    return data

def fitEncoding(X_train,y_train,X_test,y_test):

  xv_train = X_train.copy()
  yv_train = y_train.copy()
  xv_test = X_test.copy()
  yv_test = y_test.copy()

  categorical_cols = ['person_gender','person_education', 'person_home_ownership', 'loan_intent']

  # fitting dell' encoder
  encoder = OneHotEncoder(handle_unknown='ignore', sparse_output=False, drop='first')
  encoder.fit(xv_train[categorical_cols])

  encoded_features_train = encoder.transform(xv_train[categorical_cols])
  encoded_features_test = encoder.transform(xv_test[categorical_cols])

  # Crea DataFrame dalle feature codificate
  # È cruciale usare gli stessi indici e nomi di colonna per una corretta unione
  encoded_df_train = pd.DataFrame(encoded_features_train,
                                    columns=encoder.get_feature_names_out(categorical_cols),
                                    index=xv_train.index)

  encoded_df_test = pd.DataFrame(encoded_features_test,
                                   columns=encoder.get_feature_names_out(categorical_cols),
                                   index=xv_test.index)

  # Rimuovi le colonne categoriche originali e concatena le nuove colonne codificate
  X_train_processed = pd.concat([xv_train.drop(columns=categorical_cols), encoded_df_train], axis=1)
  X_test_processed = pd.concat([xv_test.drop(columns=categorical_cols), encoded_df_test], axis=1)



  return X_train_processed,yv_train,X_test_processed,yv_test

def sporcaX(X_train, y_train, inconsistenza=0,nan=0,ripetizioni=0,selezioni=0,MIA=0,input_err=0):

    xv_train = X_train.copy()
    yv_train = y_train.copy()

    # unione target al dataset per le sporcature per quando necessario avere entrambe

    df_unified = pd.concat([xv_train, yv_train], axis=1)

    # Errori di selezione
    #ipotizza che la compilazione di un dataset abbia alcuni elementi (categorici + target) compilabili attraverso la selezione di varie opzioni in un menu a tendina, questo simula l'errore in tale selezione
    #person_gender: ['female' 'male']  -> swap
    #person_education: ['Master' 'High School' 'Bachelor' 'Associate' 'Doctorate'] -> random sobstitution
    #person_home_ownership: ['RENT' 'OWN' 'MORTGAGE' 'OTHER'] -> random sobstitution
    #loan_intent: ['PERSONAL' 'EDUCATION' 'MEDICAL' 'VENTURE' 'HOMEIMPROVEMENT' 'DEBTCONSOLIDATION'] -> random sobstitution
    #loan_status (target): [0,1] -> swap

    if selezioni > 0:

      selectable_cols_name = ['person_gender','person_education', 'person_home_ownership', 'loan_intent','loan_status']
      df_unified_subset = df_unified[selectable_cols_name].copy()

      num_selection_errors = int(df_unified_subset.size * selezioni)
      if num_selection_errors > 0:
        # Ensure we don't try to add more selection errors than there are cells
        num_selection_errors = min(num_selection_errors, df_unified_subset.size)
        # Use random.sample for efficiency if adding many error values
        all_cell_indices = [(r, c) for r in range(df_unified_subset.shape[0]) for c in range(df_unified_subset.shape[1])]
        missing_cell_indices = random.sample(all_cell_indices, num_selection_errors)

        person_gender = 0
        person_education = 0
        person_home_ownership = 0
        loan_intent = 0
        loan_status = 0


        for row_idx, col_idx in missing_cell_indices:
              col_name = df_unified_subset.columns[col_idx] # Get column name from index

              #potrebbe essere migliorata con una lista mappata, ma per ora lasciamo così (principalmente per testing,debugging ed affini)

              if col_name == 'loan_status':
                loan_status += 1
                current_value = df_unified_subset.iloc[row_idx, col_idx]
                new_value = 1 - current_value # Invert the value 1-1 = 0 ; 1-0 = 1
                df_unified_subset.iloc[row_idx, col_idx] = new_value

              elif col_name == 'person_gender':
                person_gender += 1
                current_value = df_unified_subset.iloc[row_idx, col_idx]
                new_value = 'male' if current_value == 'female' else ('female' if current_value == 'male' else current_value)
                df_unified_subset.iloc[row_idx, col_idx] = new_value

              elif col_name == 'person_education':
                person_education += 1
                current_value = df_unified_subset.iloc[row_idx, col_idx]
                list_of_values = ['Master', 'High School', 'Bachelor', 'Associate', 'Doctorate']
                list_of_values.remove(current_value)
                new_value = random.choice(list_of_values)
                df_unified_subset.iloc[row_idx, col_idx] = new_value

              elif col_name == 'person_home_ownership':
                person_home_ownership += 1
                current_value = df_unified_subset.iloc[row_idx, col_idx]
                list_of_values = ['RENT', 'OWN', 'MORTGAGE', 'OTHER']
                list_of_values.remove(current_value)
                new_value = random.choice(list_of_values)
                df_unified_subset.iloc[row_idx, col_idx] = new_value

              elif col_name == 'loan_intent':
                loan_intent += 1
                current_value = df_unified_subset.iloc[row_idx, col_idx]
                list_of_values = ['PERSONAL', 'EDUCATION', 'MEDICAL', 'VENTURE', 'HOMEIMPROVEMENT', 'DEBTCONSOLIDATION']
                list_of_values.remove(current_value)
                new_value = random.choice(list_of_values)
                df_unified_subset.iloc[row_idx, col_idx] = new_value

              else:
                print(f"valore non gestito:{df_unified_subset.iloc[row_idx, col_idx]} , colonna: {col_name}, tipo: {type(df_unified_subset.iloc[row_idx, col_idx])} ")

      ## aggiornamento del dataset
      df_unified_dropped = df_unified.drop(columns=selectable_cols_name)
      data_uncleaned = pd.concat([df_unified_dropped, df_unified_subset], axis=1)

      ## divisione target e test
      xv_train = data_uncleaned.drop('loan_status', axis=1) # loan status è il nome della target nel nostro dataset
      yv_train = data_uncleaned['loan_status']

      print('')
      print('modifiche in:')
      print(f'person_gender: {person_gender}')
      print(f'person_education: {person_education}')
      print(f'person_home_ownership: {person_home_ownership}')
      print(f'loan_intent: {loan_intent}')
      print(f'loan_status: {loan_status}')
      print('')



    # Inconsistenze nei dati
    # piu' anni di lavoro (person_emp_exp) che età
    # piu' anni di credito (cb_person_cred_hist_length ) che età
    if inconsistenza > 0:
      num_inconsistent = int(len(xv_train) * 2 * inconsistenza) # max value = numrows*2 ; una riga può contenere tutte e due le incostenze

      # Colonne tra cui scegliere per le inconsistenza
      inconsistent_cols = ['person_emp_exp', 'cb_person_cred_hist_length']
      # Ottieni gli indici numerici delle colonne da corrompere
      inconsistent_col_indices = [xv_train.columns.get_loc(col) for col in inconsistent_cols]

      person_emp_exp = 0
      cb_person_cred_hist_length = 0

      # Seleziona casualmente gli indici delle righe e delle colonne
      if num_inconsistent > 0:
        # Creare una lista di tutte le possibili combinazioni (riga, colonna) per le colonne selezionate
        all_cell_indices = [(r, c_idx) for r in range(xv_train.shape[0]) for c_idx in inconsistent_col_indices]

        # Assicurati di non selezionare più celle di quelle disponibili
        num_inconsistent = min(num_inconsistent, len(all_cell_indices))
        # Seleziona casualmente gli indici delle celle
        inconsistent_cell_indices = random.sample(all_cell_indices, num_inconsistent)

        for row_idx, col_idx in inconsistent_cell_indices:
          col_name = xv_train.columns[col_idx] # Get column name from index

          if col_name == 'person_emp_exp':
            person_emp_exp += 1
            current_value= xv_train.iloc[row_idx, col_idx] # anni di lavoro
            new_value = int (current_value + xv_train.iloc[row_idx, col_idx]) # anni di lavoro pari o maggiori dell' età
            xv_train.iloc[row_idx, col_idx] = new_value

          elif col_name == 'cb_person_cred_hist_length':
            cb_person_cred_hist_length += 1
            current_value= xv_train.iloc[row_idx, col_idx] # anni di credito
            new_value = float (current_value + xv_train.iloc[row_idx, col_idx]) # anni di credito pari o maggiori dell' età
            xv_train.iloc[row_idx, col_idx] = new_value

          else:
            print(f"valore non gestito:{xv_train.iloc[row_idx, col_idx]} , colonna: {col_name}, tipo: {type(xv_train.iloc[row_idx, col_idx])} ")

        print('')
        print('inconsistenze in:')
        print(f'person_emp_exp: {person_emp_exp}')
        print(f'cb_person_cred_hist_length: {cb_person_cred_hist_length}')
        print('')

    # errore di input
    # es: per un numerico 96 diventa 69, per il categorico ciao, ciiao e simili, errori di maiuscole-minuscole, spazi/ spazi multipli, caratteri speciali quali quello di acapo ";"
    # in teroria posso sporcare anche il target senza incappare in errori di training
    if input_err > 0:
      num_input_errors = int(df_unified.size * input_err)
      loan_status = 0
      float_point_to_comma = 0
      int_swap_first_two_digits = 0
      str_swap_consecutive_char=0
      str_duplicate_random_char=0
      str_first_case_change=0
      str_endswith_multiple_spaces=0
      str_add_random_separator=0
      str_add_new_line_char=0

      if num_input_errors > 0:
        # Ensure we don't try to add more input errors than there are cells
        num_input_errors = min(num_input_errors, df_unified.size)
        # Use random.sample for efficiency if adding many
        all_cell_indices = [(r, c) for r in range(df_unified.shape[0]) for c in range(df_unified.shape[1])]
        input_cell_indices = random.sample(all_cell_indices, num_input_errors)

        for row_idx, col_idx in input_cell_indices:
          col_name = df_unified.columns[col_idx] # Get column name from index
          if col_name == 'loan_status':
            loan_status +=1
            df_unified.iloc[row_idx, col_idx] =  random.choice([np.nan,2]) if (df_unified.iloc[row_idx, col_idx]) == 1  else random.choice([np.nan,9])

          elif isinstance(df_unified.iloc[row_idx, col_idx], (float, np.floating)): # se è un numero non target float
            value= df_unified.iloc[row_idx, col_idx]
            df_unified.iloc[row_idx, col_idx] =f"{value:.2f}".replace('.', ',') # se è float sostituisci i . con le ,
            float_point_to_comma +=1

          elif isinstance(df_unified.iloc[row_idx, col_idx], (int, np.integer)): # se è un numero non target int:
                value= df_unified.iloc[row_idx, col_idx]
                if int(value) > 9:
                  number = int(df_unified.iloc[row_idx, col_idx])
                  str_number = str(number)
                  # Swap the first two digits
                  new_number = int (str_number[1] + str_number[0] + str_number[2:]) # swap dei primi due caratteri di un numero intero
                  df_unified.iloc[row_idx, col_idx] = new_number
                  int_swap_first_two_digits +=1

          elif isinstance(df_unified.iloc[row_idx, col_idx], str):
            old_str = df_unified.iloc[row_idx, col_idx]
            error_type = random.choice(['swap', 'duplicate','case_change','spazio_multiplo','separatore','acapo'])
            if error_type == 'swap': # inverte l'ordine di due caratteri consecutivi
              str_swap_consecutive_char +=1
              if len(old_str) >= 2:
                swap_index = random.randint(0, len(old_str) - 2)
                new_str = list(old_str)
                new_str[swap_index], new_str[swap_index + 1] = new_str[swap_index + 1], new_str[swap_index]
                df_unified.iloc[row_idx, col_idx] = "".join(new_str)
            elif error_type == 'duplicate': #duplica un carattere randomico
              str_duplicate_random_char +=1
              duplicate_index = random.randint(0, len(old_str) - 1)
              new_str = list(old_str)
              new_str.insert(duplicate_index, new_str[duplicate_index])
              df_unified.iloc[row_idx, col_idx] = "".join(new_str)
            elif error_type == 'case_change': #inverte la prima carattere in maiuscola o minuscola
              str_first_case_change +=1
              new_str = list(old_str)
              new_str[0].swapcase()
              df_unified.iloc[row_idx, col_idx] = "".join(new_str)
            elif error_type =='spazio_multiplo':
              str_endswith_multiple_spaces +=1
              new_str = old_str + ' ' * random.randint(1,5)
              df_unified.iloc[row_idx, col_idx] = new_str
            elif error_type =='separatore':
              str_add_random_separator +=1
              new_str = old_str+ random.choice([';','  ']) # separatori sono ; e tabulazione(rari dataset)
              df_unified.iloc[row_idx, col_idx] = new_str
            elif error_type =='acapo':
              str_add_new_line_char +=1
              new_str = old_str + '\n'
              df_unified.iloc[row_idx, col_idx] = new_str
          else:
            print(f"valore non gestito:{df_unified.iloc[row_idx, col_idx]} , colonna: {col_name}, tipo: {type(df_unified.iloc[row_idx, col_idx])} ")
        print('')
        print('input error types added:')
        print(f'loan_status: {loan_status}')
        print(f'float_point_to_comma: {float_point_to_comma}')
        print(f'int_swap_first_two_digits: {int_swap_first_two_digits}')
        print(f'str_swap_consecutive_char: {str_swap_consecutive_char}')
        print(f'str_duplicate_random_char: {str_duplicate_random_char}')
        print(f'str_first_case_change: {str_first_case_change}')
        print(f'str_endswith_multiple_spaces: {str_endswith_multiple_spaces}')
        print(f'str_add_random_separator: {str_add_random_separator}')
        print(f'str_add_new_line_char: {str_add_new_line_char}')
        print('')


    # Inserimento di valori NaN
    if nan > 0:
      # Select only numerical columns for NaN injection
      numerical_cols = xv_train.select_dtypes(include=np.number).columns.tolist()
      if numerical_cols: # Check if there are numerical columns
          num_nan_cells = int(len(xv_train) * len(numerical_cols) * nan)
          if num_nan_cells > 0:
              # Ensure indices are within bounds
              num_nan_cells = min(num_nan_cells, len(xv_train) * len(numerical_cols))
              # Select random row indices
              row_indices = np.random.randint(0, len(xv_train), num_nan_cells)
              # Select random column indices from numerical columns
              col_indices_in_numerical = np.random.randint(0, len(numerical_cols), num_nan_cells)
              # Map back to original DataFrame column names
              col_names_to_corrupt = [numerical_cols[i] for i in col_indices_in_numerical]

              # Apply NaN based on selected row and numerical column names
              for r_idx, col_name in zip(row_indices, col_names_to_corrupt):
                  xv_train.loc[xv_train.index[r_idx], col_name] = np.nan # Use .loc with actual index

    ## eliminazione valori (MIA)

    if MIA > 0:
      #verisone che inserisce MIAs anche nel target, assume che se il target è mancante è posto = 0 (nessun prestito effettuato)
      # considerare di eliminare la riga dal dataset se viene eliminata una variabile target
      num_missing_values = int(xv_train.size * MIA)
      if num_missing_values > 0:
        # Ensure we don't try to add more missing values than there are cells
        num_missing_values = min(num_missing_values, xv_train.size)
        # Use random.sample for efficiency if adding many missing values
        all_cell_indices = [(r, c) for r in range(xv_train.shape[0]) for c in range(xv_train.shape[1])]
        missing_cell_indices = random.sample(all_cell_indices, num_missing_values)
        numerical=0
        strings=0

        for row_idx, col_idx in missing_cell_indices:
              col_name = xv_train.columns[col_idx] # Get column name from index
              if isinstance(xv_train.iloc[row_idx, col_idx], (float, np.floating, int, np.integer)):
                  numerical +=1
                  xv_train.iloc[row_idx, col_idx] = np.nan # Valore sentinella per numerici
              elif isinstance(xv_train.iloc[row_idx, col_idx],(str)):
                  strings +=1
                  xv_train.iloc[row_idx, col_idx] = None # Stringa vuota per categorici
              else:
                print(f"valore non gestito:{xv_train.iloc[row_idx, col_idx]} , colonna: {col_name}, tipo: {type(xv_train.iloc[row_idx, col_idx])} ")
        print('')
        print('MIA added:')
        print(f'numerical: {numerical}')
        print(f'strings: {strings}')
        print('')




    # Ripetizione di voci del dataset
    #calcola la percentuale "ripetizioni" di elemeti da rimuovere dal dataset
    # sceglie randomicamnetne gli elementi da rimuovere e quelli da duplicare

    if ripetizioni > 0:
      num_duplicate_rows = int(len(df_unified) * ripetizioni) #utilizzo df_unified per gestire anche il target

      if num_duplicate_rows > 0:
          num_rows_to_keep = len(df_unified) - num_duplicate_rows
          # Seleziona casualmente gli indici delle righe originali da mantenere
          original_indices = random.sample(df_unified.index.tolist(), num_rows_to_keep)
          df_kept = df_unified.loc[original_indices].copy()
          # Seleziona casualmente gli indici delle righe da duplicare
          indices_for_duplicates = random.choices(df_kept.index.tolist(), k=num_duplicate_rows)
          df_duplicates = df_unified.loc[indices_for_duplicates]
          # Concatena le righe mantenute con i duplicati
          df_unified = pd.concat([df_kept, df_duplicates], ignore_index=True)
          # Reset index after concatenation to ensure a clean integer index
          df_unified.reset_index(drop=True, inplace=True)
          print(f"Aggiunti {num_duplicate_rows} duplicati. Dimensione dataset finale: {len(df_unified)}")
          # divide x e y
          xv_train = df_unified.drop('loan_status', axis=1) # loan status è il nome della target nel nostro dataset
          yv_train = df_unified['loan_status']




    return xv_train, yv_train

def prepareData(data,inconsistenza=0,nan=0,ripetizioni=0,selezioni=0,MIA=0,input_err=0):

    newData = data.iloc[:,0:-1].copy() # seleziona tutto tranne l'ulltima colonna # usa .copy() per evitare SettingWithCopyWarning
    target = data.iloc[:,-1].copy() # seleziona solo l'ultima colonna ( target )

    # Assicura che newData e target abbiano lo stesso indice prima dello split
    newData.reset_index(drop=True, inplace=True)
    target.reset_index(drop=True, inplace=True)


    X_train, X_test, y_train, y_test = train_test_split(newData, target, test_size =0.30,
                                                    stratify= target, #mantiene le proporzioni delle classi differenti dato che il dataset potrebbe essere sbilanciato
                                                    random_state= 420) #fissato random seed per replicabilità


    X_train, y_train = sporcaX(X_train,y_train,inconsistenza=inconsistenza,nan=nan,ripetizioni=ripetizioni,selezioni=selezioni,MIA=MIA,input_err=input_err)

    X_train,y_train,X_test,y_test = fitEncoding(X_train,y_train,X_test,y_test) # fitta l'encoder sul train sporco e poi lo utilizza sia per lo sporco che per il pulito per coerenza

    return X_train, X_test, y_train, y_test

def evaluate_model(model, X_test, y_test, y_pred, x_train_type ,y_train ,y_train_pred ,y_pred_proba=None, y_train_pred_proba=None):

    # Calculate metrics test
    accuracy = accuracy_score(y_test, y_pred)
    f1 = f1_score(y_test, y_pred)
    auc_test = roc_auc_score(y_test, y_pred_proba)
    conf_matrix = confusion_matrix(y_test, y_pred)

    # Calculate metrics Train (for overfitting)

    acc_train = accuracy_score(y_train, y_train_pred)
    f1_train = f1_score(y_train, y_train_pred)
    auc_train = roc_auc_score(y_train, y_train_pred_proba)

    ############

    print(f"Model: {type(model).__name__}")
    print(f"Accuracy test: {accuracy:.4f} | Accuracy Training: {acc_train:.4f}")
    print(f"F1-score test: {f1:.4f} | F1-score Training: {f1_train:.4f}")
    print(f"roc_AUC-score test:{auc_test:.4f} | roc_AUC-score Training:      {auc_train:.4f}")

    # Indice di Overfitting (differenza tra training e test performance)
    # Una differenza maggiore indica più overfitting.
    print(f"Differenza Accuracy: {acc_train - accuracy:.4f}")
    print(f"Differenza F1-score: {f1_train - f1:.4f}")
    print(f"Differenza AUC:      {auc_train - auc_test:.4f}")
    ####################
    # verifica features utilizzate
    if type(model).__name__ != 'MLPClassifier':
      feature_names = x_train_type.columns
      # non è possibile stampare le features utilizzate per il neural a causa della mancanza nel dataframe
      # utilizzato del comando per ottenere il nome delle colonne
      # però i risultati del decision sono così simili che possiamo assumere che vengano utilizzate le stesse features o molto simili
      if type(model).__name__ == 'DecisionTreeClassifier':
        print("Importanza delle Feature per Decision Tree:")
        # Ottieni l'importanza delle feature dall'attributo del modello
        importances = model.feature_importances_
        # Crea una serie per visualizzare meglio
        feature_importances_dt = pd.Series(importances, index=feature_names).sort_values(ascending=False)

        # Stampa l'importanza delle feature in formato testuale
        for feature, importance in feature_importances_dt.items():
          if importance > 0:
            if importance > 0.001:
              print(f"'{feature}': {importance:.4f}")
            else:
              print(f"'{feature}': {importance:.4e}")
      elif type(model).__name__ == 'GaussianNB':

        #stima dell' importanza
        print("\nImportanza delle Feature (stimata con Permutation Importance) per Gaussian Naive Bayes:")
        # Calcola la permutation importance per Gaussian Naive Bayes
        # Usiamo il test set per valutare l'importanza su dati non visti
        perm_importance_gnb = permutation_importance(model, X_test, y_test, random_state=42)

        # Crea una serie per visualizzare meglio, usando le medie dell'importanza
        feature_importances_gnb = pd.Series(perm_importance_gnb.importances_mean, index=feature_names).sort_values(ascending=False)
        for feature, importance in feature_importances_gnb.items():
          if importance != 0 :
            if importance > 0.001 or  importance < -0.001 :
              print(f"'{feature}': {importance:.4f}")
            else:
              print(f"'{feature}': {importance:.4e}")
    else: #test MLPClass
      feature_names_MLP = x_train_type.columns
      #print(list(feature_names_MLP))
      print("\nImportanza delle Feature (stimata con Permutation Importance) per MLP:")
      # Convert X_test to a NumPy array before calculating permutation importance
      perm_importance_mlp = permutation_importance(model, X_test.values, y_test, random_state=42)

      # Crea una serie per visualizzare meglio, usando le medie dell' importanza
      feature_importances_mlp = pd.Series(perm_importance_mlp.importances_mean, index=feature_names_MLP).sort_values(ascending=False)

      # Print the entire series to see all importance scores
      print(feature_importances_mlp)



    # Calculate ROC curve and AUC
    if y_pred_proba is not None:
        fpr, tpr, thresholds = roc_curve(y_test, y_pred_proba)
        roc_auc = auc(fpr, tpr)
        print(f"AUC: {roc_auc:.4f}")

        # Plot ROC curve
        plt.figure(figsize=(8, 6))
        plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC curve (AUC = {roc_auc:.2f})')
        plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
        plt.xlim([0.0, 1.0])
        plt.ylim([0.0, 1.05])
        plt.xlabel('False Positive Rate')
        plt.ylabel('True Positive Rate')
        plt.title('Receiver Operating Characteristic (ROC) Curve')
        plt.legend(loc="lower right")
        plt.show()
    else:
        print("AUC not calculated as predicted probabilities were not provided.")


    # Plot Confusion Matrix
    plt.figure(figsize=(8, 6))
    sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', cbar=False,
                xticklabels=['Predicted 0', 'Predicted 1'],
                yticklabels=['Actual 0', 'Actual 1'])
    plt.xlabel('Predicted Label')
    plt.ylabel('True Label')
    plt.title('Confusion Matrix')
    plt.show()

def runTestset(oldata,inconsistenza=0,nan=0,ripetizioni=0,selezioni=0,MIA=0,input_err=0):

  data = oldata.copy()

  data = downsampling(data)

  X_train, X_test, y_train, y_test = prepareData(data,inconsistenza=inconsistenza,nan=nan,ripetizioni=ripetizioni,selezioni=selezioni,MIA=MIA,input_err=input_err)

  # initiate list to store models and predictions
  models = []

  # initiate x_train_type to store X_train used
  x_train_type = []

  ####### Imputation for NaN values

  #  imputer for NaN values
  imputer = SimpleImputer(missing_values=np.nan, strategy='mean')

  # Fit on training data and transform both training and test data
  X_train_imputed = imputer.fit_transform(X_train)
  X_test_imputed = imputer.transform(X_test)

  # Convert back to DataFrame to retain column names
  # Use the index from the original X_train/X_test to maintain alignment
  X_train_imputed = pd.DataFrame(X_train_imputed, columns=X_train.columns, index=X_train.index)
  X_test_imputed = pd.DataFrame(X_test_imputed, columns=X_test.columns, index=X_test.index)



  ######## naive-bayes
  gnb = GaussianNB()
  # Use the imputed data for training and prediction
  gnb.fit(X_train_imputed, y_train)

  y_pred_gnb = gnb.predict(X_test_imputed)
  y_train_pred_gnb = gnb.predict(X_train_imputed)


  # GaussianNB might raise errors or behave unexpectedly with NaNs if not handled -> imputed NaNs
  models.append({
      'name': 'Naive Bayes',
      'model': gnb,
      'y_pred': y_pred_gnb,
      'y_pred_proba': gnb.predict_proba(X_test_imputed)[:, 1], # Get probability for the positive class
      'y_train_pred': y_train_pred_gnb,
      'y_train_pred_proba': gnb.predict_proba(X_train_imputed)[:, 1] # Get probability for the positive class
  })

  x_train_type.append({
      'name': 'Naive Bayes',
      'x_train': X_train_imputed
  })


  ######## decision-tree

  dtc = DecisionTreeClassifier(random_state=42, max_depth=6, min_samples_split=3)

  # Use the imputed data for training and prediction

  dtc.fit(X_train_imputed, y_train)

  y_pred_dtc = dtc.predict(X_test_imputed)
  y_train_pred_dtc = dtc.predict(X_train_imputed)

  # DTC can sometimes handle NaNs, but behavior varies. Used imputed data for consistency.
  models.append({
      'name': 'Decision Tree',
      'model': dtc,
      'y_pred': y_pred_dtc,
      'y_pred_proba': dtc.predict_proba(X_test_imputed)[:, 1], # Get probability for the positive class
      'y_train_pred': y_train_pred_dtc,
      'y_train_pred_proba': dtc.predict_proba(X_train_imputed)[:, 1] # Get probability for the positive class
  })

  x_train_type.append({
      'name': 'Decision Tree',
      'x_train': X_train_imputed
  })

  ###### neural network

  # Inizializziamo lo StandardScaler (necessario per il nn)
  scaler = StandardScaler()

  # Applichiamo lo scaling solo alle feature numeriche
  # Scaliamo il training set e poi trasformiamo il test set con lo stesso scaler
  X_train_scaled = scaler.fit_transform(X_train_imputed)
  X_test_scaled = scaler.transform(X_test_imputed)

  # Creiamo un'istanza della Rete Neurale
  # hidden_layer_sizes: Una tupla che specifica il numero di neuroni in ogni strato nascosto.
  #                     in questo caso: un solo strato nascosto con tot neuroni.
  # activation: Funzione di attivazione per gli strati nascosti ('relu' è il piu' utilizzato).
  # solver: Algoritmo per l'ottimizzazione dei pesi ('adam' è un default).
  # max_iter: Numero massimo di epoche.
  # random_state: Per riproducibilità.
  # alpha: Termine di regolarizzazione L2 (per prevenire overfitting).
  # learning_rate_init: Tasso di apprendimento iniziale.
  nn_model = MLPClassifier(
      hidden_layer_sizes=(30,),  # Un singolo strato nascosto con tot neuroni
     activation='relu',         # Funzione di attivazione ReLU
     solver='adam',             # Ottimizzatore Adam
     max_iter=5000,              # Numero massimo di epoche
     random_state=42,           # Random state per riproducibilità
     alpha=0.0001,              # Regolarizzazione L2 (piccola)
     learning_rate_init=0.01   # Tasso di apprendimento
  )

  # Addestramento della Rete Neurale sul training set scalato

  nn_model.fit(X_train_scaled, y_train)

  y_train_pred_nn = nn_model.predict(X_train_scaled)
  y_test_pred_nn = nn_model.predict(X_test_scaled)

  # Select only the probability for the positive class  (used later in models.append ecc)
  y_train_pred_proba_nn = nn_model.predict_proba(X_train_scaled)[:, 1]
  y_test_pred_proba_nn = nn_model.predict_proba(X_test_scaled)[:, 1]


  models.append({
      'name': 'Neural Network',
      'model': nn_model,
      'y_pred': y_test_pred_nn,
      'y_pred_proba':y_test_pred_proba_nn, # Get probability for the positive class
      'y_train_pred': y_train_pred_nn,
      'y_train_pred_proba': y_train_pred_proba_nn # Get probability for the positive class
  })


  x_train_type.append({
      'name': 'Neural Network',
      'x_train': X_train_imputed
  })


  return X_test, y_test, y_train, models, x_train_type

def main(oldata,inconsistenza=0,nan=0,ripetizioni=0,selezioni=0,MIA=0,input_err=0):

  X_test, y_test, y_train ,models,x_train_type = runTestset(oldata.copy(),inconsistenza=inconsistenza,nan=nan,ripetizioni=ripetizioni,selezioni=selezioni,MIA=MIA,input_err=input_err)

  for model in models:
    current_x_train_info = next(item for item in x_train_type if item["name"] == model["name"])
    current_x_train = current_x_train_info["x_train"]
    # Pass X_test and y_test ecc.. from the unpacked values to evaluate_model
    evaluate_model(model = model['model'], x_train_type = current_x_train,y_train = y_train ,X_test = X_test,y_test= y_test, y_pred=model.get('y_pred'), y_pred_proba=model.get('y_pred_proba'),y_train_pred=model.get('y_train_pred'),y_train_pred_proba=model.get('y_train_pred_proba'))

"""##caso pulito"""

main(data) ## caso pulito

"""## 10% di : NaN , inconsistenze , ripetizioni, selezioni, MIA, input_err"""

main(data,nan=0.1) # caso con NaN 10%

main(data,inconsistenza=0.1) # caso con inconsistenza 10%

main(data,ripetizioni=0.1) # caso con ripetizioni 10%

main(data,selezioni=0.1) # caso con errori di selezione 10%

main(data,MIA=0.1) # caso con mancanza dati 10%

main(data,input_err=0.1)

"""## NaN dal 20% al 50%"""

main(data,nan=0.2) # caso con NaN 20%

main(data, nan=0.25)

main(data,nan=0.3) # caso con NaN 30%

main(data,nan=0.4) # caso con NaN 40%

main(data , nan=0.45)

main(data,nan=0.5) # caso con NaN 50%

main(data,nan=0.6) # caso con NaN 60%

main(data,nan=0.7) # caso con NaN 70%

"""## inconsistenze dal 20% al 50%"""

main(data,inconsistenza=0.2) # caso con inconsistenza 20%

main(data,inconsistenza=0.3) # caso con inconsistenza 30%

main(data,inconsistenza=0.4) # caso con inconsistenza 40%

main(data,inconsistenza=0.5) # caso con inconsistenza 50%

main(data,inconsistenza=0.6) # caso con inconsistenza 60%

main(data,inconsistenza=0.7) # caso con inconsistenza 70%

main(data,inconsistenza=0.8) # caso con inconsistenza 80%

main(data,inconsistenza=0.9) # caso con inconsistenza 90%

"""## ripetizioni dal 20% al 50% ,80% , 999%"""

main(data,ripetizioni=0.2) # caso con ripetizioni 20%

main(data,ripetizioni=0.3) # caso con ripetizioni 30%

main(data,ripetizioni=0.4) # caso con ripetizioni 40%

main(data,ripetizioni=0.5) # caso con ripetizioni 50%

main(data,ripetizioni=0.8) # caso con ripetizioni 80%

main(data,ripetizioni=0.999)

"""## selezioni dal 20% al 50%"""

main(data,selezioni=0.2) # caso con errori di selezione 20%

main(data,selezioni=0.3) # caso con errori di selezione 30%

main(data,selezioni=0.4) # caso con errori di selezione 40%

main(data,selezioni=0.5) # caso con errori di selezione 50%

"""## mancanza dati dal 20% al 50%, 70%,90%,95%"""

main(data,MIA=0.2) # caso con mancanza dati 20%

main(data,MIA=0.3) # caso con mancanza dati 30%

main(data,MIA=0.4) # caso con mancanza dati 40%

main(data,MIA=0.5) # caso con mancanza dati 50%

main(data,MIA=0.7) # caso con mancanza dati 70%

main(data,MIA=0.9) # caso con mancanza dati 90%

"""## input_error 20-50%"""

main(data,input_err=0.2)

main(data,input_err=0.3)

main(data,input_err=0.4)

main(data,input_err=0.5)

main(data,input_err=0.6)

main(data,input_err=0.7)

main(data,input_err=0.8)